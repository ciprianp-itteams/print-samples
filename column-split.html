<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Synchronized Two-Column Spreads (Vivliostyle)</title>
<style>
  /* ===== Page config (edit for your size/margins) ===== */
  :root{
    --page-width: 210mm;   /* A4 */
    --page-height: 297mm;
    --margin-top: 20mm;
    --margin-bottom: 20mm;
    --margin-left: 18mm;
    --margin-right: 18mm;

    --content-width: calc(var(--page-width) - var(--margin-left) - var(--margin-right));
    --content-height: calc(var(--page-height) - var(--margin-top) - var(--margin-bottom));
    --gap: 10mm;           /* gap between columns */
  }

  /* Vivliostyle / print page box */
  @page {
    size: var(--page-width) var(--page-height);
    margin: var(--margin-top) var(--margin-right) var(--margin-bottom) var(--margin-left);
  }

  body { font: 12pt/1.45 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; }

  /* ===== Spreads (one per page) ===== */
  .spread {
    display: flex;
    gap: var(--gap);
    width: 100%;
    break-after: page;           /* one spread = one page */
    box-sizing: border-box;
  }
  .col {
    flex: 1 1 0;
    box-sizing: border-box;
    height: var(--content-height);  /* critical for measuring */
    overflow: hidden;               /* prevent spill during measure */
  }

  /* Optional visual column rule (prints in browsers; Vivliostyle supports real rules via backgrounds) */
  .spread { background-image: linear-gradient(90deg, transparent calc(50% - var(--gap)/2 - 0.5px), #ccc calc(50% - var(--gap)/2), #ccc calc(50% - var(--gap)/2 + 1px), transparent calc(50% - var(--gap)/2 + 1px)); background-repeat: no-repeat; background-size: 100% 100%; }

  /* Keep certain chunks intact */
  .no-split { break-inside: avoid; page-break-inside: avoid; }

  /* ===== Source containers (hidden; the script consumes them) ===== */
  #src { display: none; }

  /* On-screen demo helpers (not required with Vivliostyle) */
  .spread { padding: 0; }
  .col > * { margin: 0 0 0.6rem; }
  h2 { margin: 0.8rem 0 0.4rem; }
</style>
</head>
<body>

<!-- ===== Your original content goes here (left/right, any block elements) ===== -->
<div id="src">
  <div id="src-left">
    <h2>Left: Title</h2>
    <!-- Repeat these to test multiple pages -->
    <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer vitae…</p>
    <p class="no-split"><strong>Keep together:</strong> this block won’t split between pages.</p>
    <!-- … add lots more paragraphs/blocks … -->
  </div>

  <div id="src-right">
    <h2>Right: Title</h2>
    <p>Completely separate content from the left column. Vivliostyle will keep pages synchronized.</p>
    <!-- … -->
  </div>
</div>

<!-- The script will generate spreads into this container -->
<div id="book"></div>

<script>
/**
 * Synchronized two-column page builder for Vivliostyle.
 * Strategy: create one .spread at a time, append nodes to left/right until either side would overflow.
 * When one side overflows, back out the last append(s), finalize the spread, and start a new one.
 * This guarantees both columns advance in lockstep (same page count), at the cost of possible bottom whitespace.
 */

(function () {
  const srcLeft = document.querySelector('#src-left');
  const srcRight = document.querySelector('#src-right');
  const book = document.querySelector('#book');

  // Gather source nodes as arrays of block-level chunks (we move whole nodes).
  const leftQueue = Array.from(srcLeft ? srcLeft.childNodes : []).filter(isRenderableNode);
  const rightQueue = Array.from(srcRight ? srcRight.childNodes : []).filter(isRenderableNode);

  // Build spreads until both queues are empty.
  while (leftQueue.length || rightQueue.length) {
    const spread = document.createElement('section');
    spread.className = 'spread';

    const leftCol = document.createElement('div');
    leftCol.className = 'col left';
    const rightCol = document.createElement('div');
    rightCol.className = 'col right';

    spread.append(leftCol, rightCol);
    book.appendChild(spread);

    // Target height to not exceed
    const maxH = leftCol.clientHeight || leftCol.getBoundingClientRect().height;

    // Flags for when a column can't take more on this page
    let leftFull = false, rightFull = false;

    // We try to keep things fair: attempt one node per side in a loop
    while ((!leftFull && leftQueue.length) || (!rightFull && rightQueue.length)) {
      // Try left
      if (!leftFull && leftQueue.length) {
        if (!appendIfFits(leftCol, leftQueue[0], maxH)) {
          leftFull = true;
        } else {
          leftQueue.shift();
        }
      }
      // Try right
      if (!rightFull && rightQueue.length) {
        if (!appendIfFits(rightCol, rightQueue[0], maxH)) {
          rightFull = true;
        } else {
          rightQueue.shift();
        }
      }

      // If one column is full and the other could still accept more,
      // we STOP anyway to keep pages synchronized.
      if ((leftFull && !rightFull) || (rightFull && !leftFull)) {
        break;
      }
    }

    // If nothing fit on an empty page (e.g., a giant image),
    // force-place one big node per side to avoid infinite loop.
    if (!leftCol.childNodes.length && leftQueue.length) {
      leftCol.appendChild(leftQueue.shift());
    }
    if (!rightCol.childNodes.length && rightQueue.length) {
      rightCol.appendChild(rightQueue.shift());
    }

    // Next loop iteration creates the next page.
  }

  /*** Helpers ***/
  function isRenderableNode(n) {
    return n.nodeType === Node.ELEMENT_NODE || (n.nodeType === Node.TEXT_NODE && n.textContent.trim() !== '');
  }

  // Append a CLONE for measurement, then swap in the original to avoid reflow cost? Simpler: try with the real node and revert if needed.
  function appendIfFits(col, node, maxH) {
    // Append
    const appended = col.appendChild(node);
    // Respect "no-split": if the added node contains a .no-split that exceeds height, we still keep it together and overflow is allowed only if page empty.
    const fits = col.scrollHeight <= maxH + 0.5; // fudge for fractional pixels
    if (!fits) {
      // Revert
      col.removeChild(appended);
      return false;
    }
    return true;
  }
})();
</script>

</body>
</html>
